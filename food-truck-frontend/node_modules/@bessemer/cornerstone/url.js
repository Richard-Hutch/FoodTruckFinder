import { defaults, isString, isObject, isEmpty, take, join, map, startsWith, isNil, each, first, isArray, reverse } from 'lodash-es';
import { defaultString, splitLast, isPresent, contains, isBlank, splitFirst, removeStart, emptyToNull, split } from './util.js';
import produce from 'immer';

function encode(urlString) {
  return encodeURIComponent(urlString);
}
function decode(urlString) {
  return decodeURIComponent(urlString);
}
function decodeRequestParameter(urlString) {
  return decode(urlString.replace(/\+/g, '%20'));
}
var uriComponents = {
  PROTOCOL: 'protocol',
  AUTHORITY: 'authority',
  LOCATION: 'location',
  PATH: 'path',
  PARAMETERS: 'parameters',
  FRAGMENT: 'fragment'
};
function constructUrl(rawUrl, protocol, authority, location) {
  if (rawUrl === void 0) {
    rawUrl = null;
  }

  if (protocol === void 0) {
    protocol = null;
  }

  if (authority === void 0) {
    authority = null;
  }

  if (location === void 0) {
    location = {
      rawPath: '',
      relative: false,
      path: [],
      query: null,
      parameters: {},
      fragment: null
    };
  }

  return {
    rawUrl: rawUrl,
    protocol: protocol,
    authority: authority,
    location: location
  };
}

function parseProtocol(urlString, parseOptions) {
  var _splitFirst = splitFirst(urlString, ':'),
      potentialProtocol = _splitFirst[0],
      rest = _splitFirst[1]; // No : means no protocol is possible


  if (!isPresent(rest)) {
    return [null, urlString];
  } // This means the string started with :, so no protocol. We'll go ahead and remove the : from consideration


  if (isEmpty(potentialProtocol)) {
    return [null, rest];
  } // This means we have a host and therefore we have correctly captured the protocol


  if (startsWith(rest, '//')) {
    return [potentialProtocol, rest];
  } // Things get challenging here. If we're supporting "opaque" urls - that is urls which are not technically syntactically valid
  // then we assume that we are looking at a host/port pair


  if (parseOptions.opaque) {
    return [null, urlString];
  } // Otherwise, we need to support valid urns and can't tell the difference between an incomplete url and a urn, so since opaque is false
  // we assume it is a syntactically valid urn
  else {
      return [potentialProtocol, rest];
    }
}

function parseAuthentication(urlString) {
  // If there is no //, then we don't have authentication
  // If '//' didn't come first, then we're not looking at an authentication and we should bail
  if (!startsWith(urlString, '//')) {
    return [null, urlString];
  }

  var targetPart = removeStart(urlString, '//');

  var _splitFirst2 = splitFirst(targetPart, '@'),
      authenticationPart = _splitFirst2[0],
      rest = _splitFirst2[1]; // If there is no @, then we don't have an authentication


  if (!isPresent(rest)) {
    return [null, '//' + targetPart];
  }

  var authenticationResults = splitFirst(authenticationPart, ':'); // If there isn't a colon, then there is no password

  if (authenticationResults.length === 1) {
    return [{
      principal: first(authenticationResults),
      password: null
    }, '//' + rest];
  }

  var principal = authenticationResults[0],
      password = authenticationResults[1]; // The authentication section started with a :, don't know what to make of this... password but no username?
  // just parse out the authentication section and soldier on with no authentication information

  if (isEmpty(principal)) {
    return [null, '//' + rest];
  } // Username with no password - this is legit


  if (isEmpty(password)) {
    return [{
      principal: principal,
      password: null
    }, '//' + rest];
  } // Otherwise, we have both, so return the complete authentication object and the rest


  return [{
    principal: principal,
    password: emptyToNull(password)
  }, '//' + rest];
}

function parseHost(urlString, parseOptions) {
  // Check if the host is starting with reserved characters, if so we should just bail on trying to parse
  if (startsWith(urlString, '?') || startsWith(urlString, '#')) {
    return [null, urlString];
  }

  var hostRequired = startsWith(urlString, '//');

  if (!hostRequired && !parseOptions.opaque) {
    return [null, urlString];
  }

  urlString = removeStart(urlString, '//'); // Lets grab everything to the left of the first slash, this is the remainder of our authority (if any)

  var _splitFirst3 = splitFirst(urlString, '/'),
      authority = _splitFirst3[0],
      rest = _splitFirst3[1];

  if (isPresent(rest)) {
    rest = '/' + rest;
  } // If the rest of the url starts with a slash, then we'll assume we don't have an host and it's just starting with a path


  if (isEmpty(authority)) {
    return [null, urlString];
  }

  var hostResults = splitFirst(authority, ':'); // We have no :, which means no port, but might have a hostname

  if (hostResults.length === 1) {
    // Did we just start with a : but not have any actual values? If so, just ditch having a host
    if (isEmpty(hostResults[0])) {
      return [null, rest];
    }

    return [{
      name: hostResults[0],
      domain: parseDomain(hostResults[0]),
      port: null
    }, rest];
  }

  var name = hostResults[0],
      port = hostResults[1]; // The host started with a :, this is odd, lets just disregard

  if (isEmpty(name)) {
    return [null, rest];
  } // Otherwise, we have both, so return the complete authentication object and the rest


  return [{
    name: name,
    domain: parseDomain(name),
    port: emptyToNull(port)
  }, rest];
}

function parseDomain(domainName) {
  return reverse(split(domainName, '.'));
}

function parseAuthority(urlString, parseOptions) {
  var _parseAuthentication = parseAuthentication(urlString),
      authentication = _parseAuthentication[0],
      rest1 = _parseAuthentication[1];

  var _parseHost = parseHost(rest1, parseOptions),
      host = _parseHost[0],
      rest2 = _parseHost[1];

  if (isNil(authentication) && isNil(host)) {
    return [null, rest2];
  }

  return [{
    host: host,
    authentication: authentication
  }, rest2];
}

function parseLocation(urlString, parseOptions, context) {
  var location = {};
  location.path = [];
  location.parameters = {};
  location.relative = !isEmpty(urlString) && !startsWith(urlString, '/') && !isPresent(context.protocol) && !isPresent(context.authority);
  var urlPartition = partitionLocationInformation(urlString);
  location.rawPath = urlPartition.path;
  each(removeStart(urlPartition.path, '/').split('/'), function (urlPathPart) {
    if (!isBlank(urlPathPart) || !parseOptions.collapseEmptyPathSegments) {
      location.path.push(decode(urlPathPart));
    }
  });
  location.query = urlPartition.query;
  each(defaultString(urlPartition.query).split('&'), function (parameterPair) {
    var splitParameters = parameterPair.split('=');

    if (!isBlank(first(splitParameters))) {
      var key = decodeRequestParameter(splitParameters[0]);
      var value = '';

      if (splitParameters.length === 2) {
        value = splitParameters[1];
      }

      if (isNil(location.parameters[key])) {
        location.parameters[key] = decodeRequestParameter(value);
      } else if (!isArray(location.parameters[key])) {
        var paramList = [location.parameters[key]];
        paramList.push(decodeRequestParameter(value));
        location.parameters[key] = paramList;
      } else {
        location.parameters[key].push(decodeRequestParameter(value));
      }
    }
  });
  location.fragment = urlPartition.fragment;
  return location;
}

function partitionLocationInformation(urlString) {
  var partition = {
    path: null,
    query: null,
    fragment: null
  };
  var target = defaultString(urlString); // First, lets see if we have a fragment and parse it off the end

  var results = splitLast(target, '#');

  if (results.length === 2) {
    var _results = results,
        rest = _results[0],
        fragment = _results[1];
    partition.fragment = fragment;
    target = rest;
  } // Then lets see if we have a query string and parse it off the remainder


  results = splitLast(target, '?');

  if (results.length === 2) {
    var _results2 = results,
        _rest = _results2[0],
        query = _results2[1];
    partition.query = query;
    target = _rest;
  }

  partition.path = target;
  return partition;
}
var DEFAULT_PARSE_OPTIONS = {
  opaque: false,
  // controls whether or not we support 'opaque' parsing - ie allowing some url formats which deviate from the spec
  collapseEmptyPathSegments: true // controls whether or not we allow empty path segments in the parsed structure

};
var DEFAULT_URI_PARSE_OPTIONS = DEFAULT_PARSE_OPTIONS;
var DEFAULT_URL_PARSE_OPTIONS = defaults({
  opaque: true
}, DEFAULT_PARSE_OPTIONS);
var DEFAULT_HREF_PARSE_OPTIONS = defaults({}, DEFAULT_PARSE_OPTIONS);
function parseUri(urlString, parseOptions) {
  if (parseOptions === void 0) {
    parseOptions = DEFAULT_URI_PARSE_OPTIONS;
  }

  if (!isString(urlString)) {
    return urlString;
  }

  var context = {};

  var _parseProtocol = parseProtocol(urlString, parseOptions),
      protocol = _parseProtocol[0],
      rest1 = _parseProtocol[1];

  context.protocol = protocol;

  var _parseAuthority = parseAuthority(rest1, parseOptions),
      authority = _parseAuthority[0],
      rest2 = _parseAuthority[1];

  context.authority = authority;
  var location = parseLocation(rest2, parseOptions, context);
  return constructUrl(urlString, protocol, authority, location);
}
function parseUrl(urlString, parseOptions) {
  if (parseOptions === void 0) {
    parseOptions = DEFAULT_URL_PARSE_OPTIONS;
  }

  return parseUri(urlString, parseOptions);
}
function parseHref(urlString, parseOptions) {
  if (parseOptions === void 0) {
    parseOptions = DEFAULT_HREF_PARSE_OPTIONS;
  }

  return parseUri(urlString, parseOptions);
}
function resolveHref(baseUrl, targetUrl) {
  if (!isObject(targetUrl)) {
    targetUrl = parseHref(targetUrl);
  }

  if (isPresent(targetUrl.authority)) {
    return targetUrl;
  }

  if (!isObject(baseUrl)) {
    baseUrl = parseUrl(baseUrl);
  }

  var resolvedUrl = produce(baseUrl, function (draft) {
    draft.location.query = targetUrl.location.query;
    draft.location.parameters = targetUrl.location.parameters;
    draft.location.fragment = targetUrl.location.fragment;

    if (isEmpty(draft.location.path) || !targetUrl.location.relative) {
      draft.location.path = targetUrl.location.path;
    } else if (!isEmpty(targetUrl.location.path)) {
      draft.location.path = [].concat(take(draft.location.path, draft.location.path.length - 1), targetUrl.location.path);
    }

    draft.rawUrl = formatUrl(draft);
    draft.location.rawPath = formatLocation(draft.location);
  });
  return resolvedUrl;
}
function formatUrl(url, options) {
  if (options === void 0) {
    options = {
      excludeComponents: []
    };
  }

  var _options = options,
      excludeComponents = _options.excludeComponents;
  var urlString = '';

  if (isPresent(url.protocol) && !contains(excludeComponents, uriComponents.PROTOCOL)) {
    urlString = urlString + url.protocol;
  }

  if (isPresent(url.authority) && !contains(excludeComponents, uriComponents.AUTHORITY)) {
    if (isPresent(url.protocol)) {
      urlString = urlString + '://';
    }

    if (isPresent(url.authority.authentication)) {
      urlString = urlString + url.authority.authentication.principal;

      if (isPresent(url.authority.authentication.password)) {
        urlString = urlString + ':' + url.authority.authentication.password;
      }

      urlString = urlString + '@';
    }

    urlString = urlString + url.authority.host.name;

    if (isPresent(url.authority.host.port)) {
      urlString = urlString + ':' + url.authority.host.port;
    }
  }

  if (!contains(excludeComponents, uriComponents.LOCATION)) {
    var locationString = formatLocation(url.location, options);

    if (locationString !== '/' || isEmpty(urlString)) {
      urlString = urlString + locationString;
    }
  }

  return urlString;
}
function formatLocation(location, options) {
  if (options === void 0) {
    options = {
      excludeComponents: []
    };
  }

  var urlString = '/';
  var _options2 = options,
      excludeComponents = _options2.excludeComponents;
  var includePath = !isEmpty(location.path);
  var includeParameters = !isEmpty(location.query) && !contains(excludeComponents, uriComponents.PARAMETERS);
  var includeFragment = !isBlank(location.fragment) && !contains(excludeComponents, uriComponents.FRAGMENT);

  if (includePath) {
    var path = join(map(location.path, function (pathPart) {
      return encode(pathPart);
    }), '/');
    urlString = urlString + path;
  }

  if (includeParameters) {
    urlString = urlString + '?' + location.query;
  }

  if (includeFragment) {
    urlString = urlString + '#' + encode(location.fragment);
  }

  return urlString;
}
function empty() {
  return constructUrl();
}

export { constructUrl, decode, decodeRequestParameter, empty, encode, formatLocation, formatUrl, parseHref, parseUri, parseUrl, partitionLocationInformation, resolveHref, uriComponents };
